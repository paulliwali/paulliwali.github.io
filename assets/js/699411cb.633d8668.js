"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[12406],{26952:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"slip-box/reference-notes/Functional Data Engineering","title":"Functional Data Engineering","description":"Metadata:","source":"@site/docs/slip-box/reference-notes/Functional Data Engineering.md","sourceDirName":"slip-box/reference-notes","slug":"/slip-box/reference-notes/Functional Data Engineering","permalink":"/docs/slip-box/reference-notes/Functional Data Engineering","draft":false,"unlisted":false,"editUrl":"https://github.com/paulliwali/paulliwali.github.io/tree/main/docs/docs/slip-box/reference-notes/Functional Data Engineering.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Frequentist Inference Testing","permalink":"/docs/slip-box/reference-notes/Frequentist Inference Testing"},"next":{"title":"\ud83d\udcf0 Summary (use your own words)","permalink":"/docs/slip-box/reference-notes/GPT in SQL"}}');var s=t(74848),r=t(28453);const a={},o=void 0,l={},c=[];function d(e){const n={a:"a",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Metadata:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"#article #data-science"}),"\n",(0,s.jsxs)(n.li,{children:["Source: ",(0,s.jsx)(n.a,{href:"https://maximebeauchemin.medium.com/functional-data-engineering-a-modern-paradigm-for-batch-data-processing-2327ec32c42a",children:"Functional Data Engineering"})]}),"\n",(0,s.jsx)(n.li,{children:"Modern paradigm for batched data processing"}),"\n",(0,s.jsx)(n.li,{children:"ETL (extract, transform and load) is a time-consuming, brittle and often unrewarding process"}),"\n",(0,s.jsxs)(n.li,{children:["Functional programming paradigm can bring clarity to the process","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["A style of building the structure and elements of computer programs that treats ",(0,s.jsx)(n.strong,{children:"computation as the evaluation of mathematical functions and avoid changing-state and mutable data"})]}),"\n",(0,s.jsxs)(n.li,{children:["A declarative programming paradigm, meaning programming is done with expressions or declarations, ",(0,s.jsx)(n.strong,{children:"instead of statements"})]}),"\n",(0,s.jsxs)(n.li,{children:["Functional code outputs code that only depend on the arguments that are passed to the function","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"Calling the same function twice with the same argument will produce the same result each time"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["In contrast to ",(0,s.jsx)(n.strong,{children:"procedures that depend on a local or global state"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Reproducibility and replicability are the key characteristics we are after","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In order to do this, we want ",(0,s.jsx)(n.strong,{children:"immutable data along with versioned logic"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Write only ",(0,s.jsx)(n.strong,{children:"pure tasks"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"These are deterministic and idempotent"}),"\n",(0,s.jsx)(n.li,{children:"No side-effects to things outside the scopes of the task"}),"\n",(0,s.jsx)(n.li,{children:"When tasks inevitably fail, they can be re-run without any concerns of double-counting or overwriting unintentionally"}),"\n",(0,s.jsxs)(n.li,{children:["Instead of returning something like a pure-function - it ",(0,s.jsx)(n.strong,{children:"overwrites a partition of the data"})," which is akin to the immutable object that a typical pure function would return"]}),"\n",(0,s.jsx)(n.li,{children:"Should only target a single output"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Table partitions as immutable objects","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Don't use DML operations like UPDATE, APPEND, DELETE"}),"\n",(0,s.jsx)(n.li,{children:"A pure task should fully overwrite a partition as its output"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Use dimension snapshots to handle slowly changing dimensions"}),"\n",(0,s.jsx)(n.li,{children:"Use separate event time and processing time to handle late arriving facts"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(96540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);