# Case Studies
##  KPI For a new product

Q: Discuss why meta would want to build this product, how would you set goals for this product and how do you measure success? (product rationale)
A: At Tesla, everything we build was aligned with the mission of accelerating the world's transition to sustainable energy. I think that is the same with Meta, where I believe the mission is to hearken to the promise of the internet which is to connect people from all edges of the world. So the goal of the product should be "enabling the live exchange of communication between people". We should measure this in a few ways - one is regarding reach or coverage and one is regarding meaningful engagement. For both of these KPIs, I also see two sides one from the audience and one from the creator side. Maybe I would track the MAU from the creator side and the MAU (with significant threshold) from the audience side. 

Follow up questions
Q: How do you deal with cannibalization of another product
A: If there is cannibalization, it must mean this product is filling a void that the customers want. If it doesn't compete in objective with the other product then it just might mean this is what the customer want and if we don't create it, a competitor will.

Q: What if someone comes to you and says revenue metrics is bad and here is a better product but goes against your goal metrics?
A: We should vertically align on the goal metric for the product, at Tesla a lot of our metrics are iterated over and over to reflect business and engineering needs. So that one number can clearly track the progress of the program for everyone. We can incorporate the suggested KPIs with revenue aspects. 

Success metrics - activation rate, retention rate, revenue growth, usage, engagement
Guardrail metrics - bounce rate, error rate, support requests, abort rate, rate of single use over power use

## AB Testing

# Data Science

## Generic

Q: What is your EDA process?
A: When conducting EDA, I first ensure I understand the data's structure and coverage. I then calculate descriptive statistics like mean, median, standard deviation, and quartiles to get a sense of the data's central tendency and variability. Next, I create visualizations like histograms, box plots, and scatter plots to understand the data's distribution, identify potential outliers, and explore relationships between variables. I also perform data quality checks, such as checking for duplicates and missing values, to ensure the data is reliable. My EDA process is flexible and adapts to the specific dataset and problem I'm trying to solve

Q: How do you handle missing data?
A: Handling missing values depends on the specific context and application, and there's no one-size-fits-all solution. If a feature has a lot of missing values, it might be best to exclude it from the analysis to avoid biasing the model. And for sparse missing values, using the mean or nearest neighbor imputation can be effective, depending on the context. Interpolation is a great technique for time series data, where the missing values can be estimated based on the patterns and trends in the data. If the data is missing at random then imputing might be appropriate but if its not at random then more sophisticated methods or throw out might be needed.

Q: Describe regularization and why it is important
A: It prevents overfitting by penalizing the size of the coefficients or the number of coefficients. Lasso reduces all coefficients and Ridge tries to penalize the higher power ones to reduce their effects.

Q: What are ensemble methods and why might they be useful?
A: They aggregate weak models together to create a stronger model. They tend to generalize better than the individual models

Q: What is ordinal data
A: Data that are categories but have inherent ranking to it, label encoding is useful here. Other type is nominal data, which doesn't have ranking and using one-hot encoding or binary encoding works. One would use binary encoding if the nominal data has high-cardinality since it is more compact than one-hot encoding.

Q: What is target encoding
A: To encode the categorical feature with the mean value of another target feature. 

Q: Name some common feature types
A: Categorical (nominal and ordinal), numerical (continuous, discrete), binary, free text, time series (timestamps, datetime), geospatial (zip code, lat/long), derived 

Q: What is the difference between normalize and standardize
A: Normalize makes the feature between 0 and 1, standardize makes the feature to have 0 mean and 1 standard deviation

## Time series ad revenue

Q: What is the daily revenue generated by this product in the last 30 days in US?
```python
import pandas as pd 

df["ds"] = pd.to_datetime(df["ds"])
df_agg = df.groupby(["country_code", "ds"])[["revenue_local"]].sum()

display(
	df_agg.loc[(df_agg["country_code"] == "US") & (df_agg["ds"] > (pd.to_datetime('now').date() - pd.TimeDelta(days=30)))]
)
```

Q: What is the daily revenue generated every day globally

```python 
import pandas as pd 

df_daily_fx_rates["ds"] = pd.to_datetime(df_daily_fx_rates["ds"])

df_with_currency = df.merge(df_country_currency_mapping[["country_code", "currency_code"]], how="left", on=["country_code"])
df_with_fx_rate = df_with_currency.merge(df_fx_rate.loc[df_fx_rate["destination_currency"] == "CAD"], how="left", left_on=["ds", "currency_code"], right_on=["ds", "source_currency"])
df_with_currency["revenue_cad"] = df_with_currency["revenue_local"] * df_with_currency["fx_rate"]

df_agg = df_with_currency.groupby(["country_code", "ds"])[["revenue_cad"]].sum()

```

Q: When do we reach 1M USD?
```python
df_with_currency.groupby("ds")[["revenue_cad"]].sum().reset_index()
df_with_currency["cumsum_revenue_cad"] = df_with_currency["revenue_cad"].cumsum()

min_date = df_with_currency.loc[df_with_currency["cumsum_revenue_cad"] >= 1000000, "ds"].min()
```

Q: Assume a linear YoY growth rate, can you provide a forecasted daily revenue?
A: One can select different ranges to compute the growth rate, should discuss some thoughts about choosing the range and the trade-offs. Using the full year is probably the safest, but won't capture any new trends that may have influenced the growth permanently.
## Fill NAN

Q: Fill NAN with the mean of the previous n values

```python 
data = {
	'user_id': [1, 1, 1, 2, 2, 2], 
	'date': ['2022-01-01', '2022-01-02', '2022-01-04', '2022-01-01', '2022-01-02', '2022-01-03'], 
	'likes': [10, 20, np.nan, 5, 10, np.nan]
}
df = pd.DataFrame(data)

# Impute missing values using SMA
imputed_df = impute_missing_values(df, window_size=2, column_name='likes')
```

A: The `imput_missing_values` function can use `groupby` then `apply..lambda` with a `fillna` and `rolling` chain. Remember to add a window size value because it includes the current value

```python
def impute_missing_values(df, window_size, column_name):
	df_imputed = df.groupby('user_id')[column_name].apply(
	  lambda x: x.fillna(x.rolling(window=window_size+1, min_periods=1).mean())
	)

	# do some merge to get other columns

	return df_imputed
```

Q: Impute missing values using median for numerical columns and mode for categorical columns
A: 
```python
def impute_missing(df):
	for colname in df.columns:
		if df[colname].dtype == "O": # categorical 
			df[colname].fillna(df[colname].mode().iloc[0], inplace=True)
		elif pd.api.types.is_numeric_dtype(df[colname]): # numeric
			df[colname].fillna(df[colname].mean().iloc[0], inplace=True)
		else:
			print("Not filling as column is neither categorical or numeric")
	return df
```

## Feature processing

Q: Can you convert categorical features into numeric
A:
```python
# Sample data
data = {'color': ['red', 'blue', 'green', 'red', 'blue', 'green']}
df = pd.DataFrame(data)

# Map to a single feature using dictionary
color_map = {"red": 0, "blue": 1, "green": 2}
df["color_mapped"] = df["color"].map(color_map)

# Map to multiple columns using pandas built-in get_dummies
pd.get_dummies(df["color"])
```

Q: Can you filter for outliers
A: 
```python
data = [10, 12, 14, 15, 18, 20, 22, 24, 100, 200]

def detect_outliers(data):
  df = pd.DataFrame(data, columns=["value"])
  q1 = df['value'].quantile(0.25)
  q3 = df['value'].quantile(0.75)
  iqr = q3 - q1
  lower_bound = q1 - (1.5 * iqr)
  upper_bound = q3 + (1.5 * iqr)

  outliers = df.loc[(df["value"] < lower_bound) | (df['value'] > upper_bound)]

  return outliers

print(detect_outliers(data))
```

## Regression

Q: Can you create a simple linear regression
A: The minimization of OLS becomes coef_1 = SS_xy / SS_xx and coef_2 = y - coef_1 * x, where SS_xy is the sum of squared cross deviation and SS_xx is the sum of squared deviation
```python
mean_x = np.mean(X)
mean_y = np.mean(y)
n = len(y)

SS_xy = np.sum(y*X) - (n * mean_x * mean_y)
SS_xx = np.sum(X**2) - (n * mean_x ** 2)

b_1 = SS_xy / SS_xx
b_0 = mean_y - b_1 * mean_x
```

# Programming

Q: How to transpose a list of lists
A: First ensure all lists are the same length, then use `zip` to iterate multiple elements

```python
[list(row) for row in zip(*master_list)]
```

Q: Why is a hashmap efficient
A: Because it is index and the lookup doesn't grow with the size and is constant time

Q: given a list of numbers, count the frequency
A: Use `Counter` or iterate through and update to a `dict` with `get('key', 0)`

Q: Implement MSE
A:
```python 
def mse(y_true, y_pred):
	error = y_pred - y_true
	squared_error = error ** 2
	mse = sum(squared_error) / len(squared_error)
	return mse
```

Q: Implement a min-max scaler
A:
```python 
def min_max_scaler(x_values):
	min_x = min(x_values)
	max_x = max(x_values)

	scaled_x = (x_values - min_x) / (max_x - min_x)
	return scaled_x
```

Q: implement cosine similarity calculation
A: consine similarity is comparing how close two vectors are against each other, basically calculating the degree between the two vectors. Calculated by dividing the dot product between the vectors and the product of the magnitude of the two vectors. The magnitude is calculate by the Pythagorean Theorem

```python

```